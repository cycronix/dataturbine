<!doctype html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
<meta http-equiv="content-style-type" content="text/css">
<link rel="stylesheet" type="text/css" href="style.css">
<title>ProGuard Troubleshooting</title>
</head>
<body>

<h2>Troubleshooting</h2>

<h3>Problems while processing</h3>

ProGuard may print out some notes and non-fatal warnings:
<ul>
<li>If your code contains <b>class casts of dynamically created class
    instances</b>, like
    "<code>(MyClass)Class.forName(variable).newInstance()</code>", ProGuard
    will list them. Depending on your application, you may need to keep the
    mentioned classes with an option like "<code>-keep class MyClass</code>",
    or their implementations with an option like "<code>-keep class *
    implements MyClass</code>". You can switch off these notes by specifying
    the <code>-dontnote</code> option.
    <p>

<li>If you get notes about <b>duplicate definitions of input classes</b>, your
    program jars or library jars contain multiple definitions of the listed
    classes. ProGuard continues processing as usual, only considering the
    first definition. The warning may be an indication of some problem though,
    so it's advisable to remove the duplicates. A convenient way to do so is
    by specifying filters on the input jars or library jars. You can switch
    off these notes by specifying the <code>-dontnote</code> option.
    <p>

<li>If you get a warning about <b>duplicate resource files or zip entries</b>,
    your input jars or resource jars contain multiple resource files with the
    same name. ProGuard continues copying the resource files as usual,
    skipping any files with previously used names. Once more, the warning may
    be an indication of some problem though, so it's advisable to remove the
    duplicates. A convenient way to do so is by specifying filters on the
    input jars or resource jars. There is no option to switch off these
    warnings.

</ul>
<p>

ProGuard may terminate when it encounters parsing errors or I/O errors, or
some more serious warnings:
<ul>
<li>If you get an error message about <b>missing <code>-keep</code>
    options</b>, you either forgot them or you mistyped the class names.
    ProGuard has to know exactly what you want to keep: an application, an
    applet, a servlet, a midlet,..., or any combination of these. Without the
    proper seed specifications, ProGuard would mark all class files as unused,
    and your output jar would be empty.
    <p>

<li>If there are <b>unresolved references to superclasses or interfaces</b>,
    you most likely forgot to specify an essential library. At least the Java
    run-time library should be specified. Furthermore, all libraries with
    classes or interfaces that are extended or implemented by classes in your
    input jars should be specified. For specifying libraries, use the
    <code>-libraryjars</code> option.
    <p>
    If the class that is reported as missing is a non-public library class,
    you should specify the <code>-dontskipnonpubliclibraryclasses</code>
    option. A common example is the class
    <code>java.util.zip.ZipConstants</code>, which is used as an interface
    class in some public classes, even though it is only package visible (in
    this case, the warning could also be ignored, because the class is not a
    fundamental part of the class hierarchy).
    <p>
    If you're missing a library and you're absolutely sure it isn't used
    anyway, you can try your luck with the <code>-ignorewarnings</code>
    option, or even the <code>-dontwarn</code> option.
    <p>

<li>If there are <b>unresolved references to class members in input
    classes</b>, your class files are most likely inconsistent. Possibly, some
    class file didn't get recompiled properly, or some class file was left
    behind after its source file was removed. Try removing all class files,
    recompiling them, zipping them up, and running ProGuard again.

</ul>
<p>

Should ProGuard crash while processing your application:
<ul>
<li>If you get an <code><b>OutOfMemoryError</b></code>, you can try increasing
    the heap size of the Java virtual machine (with the usual
    <code>-Xms</code> and <code>-Xmx</code> options). You can also reduce the
    amount of memory that ProGuard needs by removing unnecessary library jars
    from your configuration. Remember that only libraries containing classes
    or interfaces that are extended or implemented by classes in your input
    jars are required.
    <p>

<li>Maybe your class files are corrupt. See if recompiling them and trying
    again helps. If not, please report the problem, preferably with the
    simplest example that causes ProGuard to crash.
</ul>
<p>

<h3>Problems at run-time</h3>

If ProGuard runs fine, but your processed application doesn't work, there
might be several reasons:
<ul>

<li>If you are working on Windows and it looks like <b>some classes have
    disappeared</b> from your output, you should make sure you're not writing
    your output class files to a directory (or unpacking the output jar). On
    platforms with case-insensitive file systems, such as Windows, unpacking
    tools often let class files with similar lower-case and upper-case names
    overwrite each other. If you really can't switch to a different operating
    system, you could consider using ProGuard's
    <code>-dontusemixedcaseclassnames</code> option.
    <p>

<li>If ProGuard is <b>not keeping the right classes or class members</b>, make
    sure you are using fully qualified class names. If the package name of
    some class is missing, ProGuard won't match the elements that you might be
    expecting. It may help to double-check for typos too. You can use the
    <code>-printseeds</code> option to see which elements are being kept
    exactly.
    <p>

<li>If you get a <code><b>NoClassDefFoundError</b></code>, your class path is
    probably incorrect. It should at least contain all library jars and, of
    course, your processed program jar.
    <p>

<li>If you get a <code><b>ClassNotFoundException</b></code>, your code is
    probably calling <code>Class.forName</code>, trying to create the missing
    class dynamically. ProGuard can only detect constant name arguments, like
    <code>Class.forName("mypackage.MyClass")</code>. For variable name
    arguments like <code>Class.forName(someClass)</code>, you have to keep all
    possible classes using the <code>-keep</code> option, e.g. "<code>-keep
    class mypackage.MyClass</code>" or "<code>-keep class * implements
    mypackage.MyInterface</code>".
    <p>

<li>If you get a <code><b>NoSuchMethodException</b></code>, your code is
    probably calling something like <code>myClass.getMethod</code>, trying to
    find some method dynamically. Since ProGuard isn't detecting this (yet),
    you have to keep the missing method in using the <code>-keep</code>
    option, e.g. "<code>-keep class mypackage.MyClass { void myMethod();
    }</code>".
    <p>

<li>If you get a <code><b>NullPointerException</b></code> or if you don't see
    any icons, your processed code may be unable to find some resource files.
    ProGuard currently simply copies resource files over from the input jars
    or, if specified, from the resource jars, to the output jar. Their names
    and contents remain unchanged. If you've used the
    <code>-defaultpackage</code> option, the package names of some classes may
    have changed, and along with them, the directory in which they look for
    their resource files. It's better not to use this option in these
    circumstances.
    <p>

<li>If you get an <code><b>InvalidClassException</b></code> or a
    <b>verification error</b> in J2ME, you may have forgotten to preverify
    your program jar <i>after</i> having processed it with ProGuard.
    <p>
    Also, J2ME developers on Windows should note that the
    <code>preverify</code> tool always unpacks the jars it processes. It may
    thus let similarly named class files overwrite each other, as discussed in
    the first item on this list.
    <p>

<li>If you get a <code><b>ClassFormatError</b></code> mentioning a "repetitive
    field name/signature", you are probably processing some code that has been
    obfuscated before with the <code>-overloadaggressively</code> option. You
    should then use the same option again in the second processing round.
    <p>

<li>If you get a <code><b>NoSuchMethodError</b></code> or an
    <code><b>AbstractMethodError</b></code>, again you should make sure you're
    not writing your output class files to a directory on a platform with a
    case-insensitive file system, such as Windows. Please refer to the first
    item on this list for details.
    <p>
    Furthermore, you should check whether you have specified your program jars
    and library jars properly. Program classes can refer to library classes,
    but not the other way around.
    <p>
    If all of this seems ok, perhaps there's a bug in ProGuard (gasp!). If so,
    please report it, preferably with the simplest example on which you can
    find ProGuard to fail.

</ul>
<p>

<hr>
<address>
Copyright &copy; 2002-2004
<a href="http://www.graphics.cornell.edu/~eric/">Eric Lafortune</a>.
</address>
</body>
</html>
