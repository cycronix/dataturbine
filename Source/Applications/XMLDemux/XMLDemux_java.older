/* XMLDemux - demux binary data
*  runs as plugin, subscribing to UDPCapture/UDP channel
*
* EMF
* 4/12/05
* for IOScan
*
* JPB 
*
*
*   Modified Version for header version 8,4,4,8
*
*
*
*/
   import com.rbnb.utility.ArgHandler;
   import com.rbnb.sapi.ChannelMap;
   import com.rbnb.sapi.Sink;
   import com.rbnb.sapi.Source;
   import com.rbnb.utility.ByteConvert;
   import java.io.ByteArrayInputStream;
   import java.io.DataInputStream;
   import java.lang.String;
   import com.rbnb.utility.RBNBProcess;
   import java.io.*;
   import java.util.Vector;
   import java.util.TimerTask;
   import java.util.Timer;
   import java.util.Date;
	
public class XMLDemux{
   	 
    String serverAddress="localhost:3333";
    String serverAddressOut="localhost:3333";
    int archive=0;  // default archive is off
    int cache=1000;  // was 100, larger helps build larger framesets = more efficient
    double start = 0.;
    String reference = null;
    int tstampField=1;
    int Nmarker=8;
    String mode=new String("none");
    String In=null;
    String out=null;
    boolean multichan= true;  // multiple channels, i.e. RBO per chan
    boolean roundtime= false;  // round times to nearest second (to enhance time-compression)
    boolean swapBytes=true;    // word order swap
    long duration = 600000;  //write to disk every x, default 10 minutes
   
    Sink snk=new Sink();
    //     SafeSource src;
    Source src;
    ChannelMap cmin=new ChannelMap();
    
    //Vector cmv=new Vector();
    
    XMLParser xml;
    String XMLFile = null;
    
    boolean s = false;  //silent, default is debugging on
    boolean s2 = false; //boolean to print every 100 data points
    int count = 0;  //counts number of packets read
    
    //-------------------------------------------------------------------------
    //Main
    public static void main(String[] arg) throws Exception {
	new XMLDemux(arg).start();
    }
   
    //-------------------------------------------------------------------------
    //Constructor
    public XMLDemux(String[] arg) throws Exception {
       
         try {
            ArgHandler ah=new ArgHandler(arg);
            if (ah.checkFlag('h')) {
               System.err.println("XMLDemux");
               System.err.println(" -h                  : print this usage info");
               System.err.println(" -a <server address> : address of RBNB server to write packets to");
               System.err.println("             default : localhost:3333");
               System.err.println(" -x <name>           : name of XML file");
               System.err.println(" -k <num>            : archive (disk) frames");
               System.err.println("             default : 0 (no archiving)");
               System.err.println(" -i <name>           : name of input");
               System.err.println(" -o <name>           : name of output (default=UnitIDFormatID");
//               System.err.println(" -s                  : turn on silent mode");
               System.err.println(" -m                  : turn on multiple channels (default on)");
               System.err.println(" -M                  : turn OFF multiple channels");
               System.err.println(" -R                  : turn on rounded-times");
               System.err.println("                     : default is one channel");
//               System.err.println(" -t                  : time out for SafeSource in ms (default 10 min)");
               System.err.println(" -S                  : silent mode");
               System.err.println(" -s                  : start (default 0)");
               System.err.println(" -T                  : timestamp param position (0=localTime)");
               System.err.println(" -b                  : if set, use native bytes (default = swap)");
               System.err.println(" -r                  : reference (default newest)");
 
               RBNBProcess.exit(0);
            }
         
         	//single/multiple channels 
            if (ah.checkFlag('m')){
               multichan = true;            
            } // else multichan = false;  // no else, let the default be true
         
         	//single/multiple channels 
            if (ah.checkFlag('M')){
               multichan = false;            
            }
         
         	//single/multiple channels 
            if (ah.checkFlag('R')){
               roundtime = true;            
            } else roundtime = false;

                 	// native bytes flag 
            if (ah.checkFlag('b')){
               swapBytes = false;            
            } else swapBytes=true;
         
         	//input 
            if (ah.checkFlag('i')){
               In = ah.getOption('i');            
            }
         
         	//silent
            if (ah.checkFlag('S')){
               s = true;            
            } else s = false;
                  		
         	//timestamp parameter field
            if (ah.checkFlag('T')){
		String tsf = ah.getOption('T');
		tstampField = Integer.parseInt(tsf);            
            } else tstampField = 1;
                  		
         	//XML file
            if (ah.checkFlag('x')){
               XMLFile = ah.getOption('x');            
            }
         
         	//server
            if (ah.checkFlag('a')) {
               String serverAddressL=ah.getOption('a');
               if (serverAddress!=null) serverAddress=serverAddressL;
            }
            if (ah.checkFlag('A')) {
               String serverAddressL=ah.getOption('A');
               if (serverAddressOut!=null) serverAddressOut=serverAddressL;
            }
            else serverAddressOut = serverAddress;

         	//output
            if (ah.checkFlag('o')) {
               out = ah.getOption('o');
            }
         
         	//archive
            if (ah.checkFlag('k')) 
            {
               String naf=ah.getOption('k');
               if (naf!=null) archive=Integer.parseInt(naf);
               if (archive>0) {
                  mode=new String("append");  // was create
                  if (archive<cache) cache=archive;
               }
            }
         
         	//flushes the cache every -t miliseconds
            if (ah.checkFlag('t')) {
               String dur = ah.getOption('t');
               if(dur!=null) duration = Integer.parseInt(dur);
            }
         
            if(ah.checkFlag('s')) {
                String strt = ah.getOption('s');
                if(strt != null) start = Double.parseDouble(strt);
            }
            
            if(ah.checkFlag('r')) {
                reference = ah.getOption('r');
            }
            
            if (ah.checkFlag('n')) {
               String nm = ah.getOption('n');
               if(nm!=null) Nmarker = Integer.parseInt(nm);
            }
         } 
             catch (Exception e) {
               System.err.println("Exception parsing arguments");
               e.printStackTrace();
               RBNBProcess.exit(0);
            }
      
      	//check for xml file      
         if(!(new File(XMLFile)).exists())
         {
            System.err.println("!!! Could not open XML file: "+XMLFile);
            System.exit(0);			
         }      
         xml = new XMLParser(XMLFile); 		
      
      	//Create SafeSource (corrupts data on flush ?? -mjm)
//         src=new SafeSource(duration);
        src = new Source();
        
      	//open RBNB connections
         snk.OpenRBNBConnection(serverAddress,"DemuxSink");
         System.err.println("Connected to sink: "+serverAddress);

      	//add new channel map      
         cmin.Add(In);  
         if(reference == null || reference.equals("")) 	{
            System.err.println("Running subscribe-by-frame newest mode");
            snk.Subscribe(cmin);
         } else {
            System.err.println("Running subscribe-by-time mode: "+start+", "+reference);
            snk.Subscribe(cmin,start,0,reference);
         }
         
         src.SetRingBuffer(cache,mode,archive);
      	
      	//open connection
         String []info = xml.getInfo();      

         System.err.println("marker: "+xml.getMarker());
      	 if(out == null) {
	     String suffix = "";  // was "Demux"
	     out = xml.getMarker();
	     if(out.length() >= 16) out = out.substring(8,16);  // presumes certain marker format
	     out = out + suffix;
	 }

         System.err.println("Output to: " + out);
         System.err.println("Connecting to source: "+serverAddressOut);
         src.OpenRBNBConnection(serverAddressOut,out); 
         System.err.println("Connected to Source: "+serverAddressOut);

      	//registering channel map with channel info 
         ChannelMap temp = new ChannelMap();
         String []label = xml.getLabel();
	 String []id = xml.getID();
         String []type = xml.getType();
         String cname = "";

         for(int i=1; i<=xml.getNParam(); i++) {
	    
	    if(label[i] == null) cname = id[i];
	    else                 cname = label[i];
	    cname=cname.replace('/', ' ');      //remove '/' from chan names (causes RBNB problems)          

            System.out.println("Adding Channel "+i+" "+cname);
            int idx  = temp.Add(cname);
            if(info[i] != null) temp.PutUserInfo(idx,info[i]);
	    else                temp.PutUserInfo(idx,"<null userinfo>");    // need to put userInfo on all or none
         }
	 
	 /*adding latency channel */
         int idx = temp.Add("_Latency");
         temp.PutUserInfo(idx,"Data_timestamp - Creare_recieved");
      	
         src.Register(temp); 
       }
   
   	//-------------------------------------------------------------------------
   	//loop listening for incoming data
       public void start() throws Exception {
         int index=0;
            	
         while (true) 
         {
            count++;
         	
            //print channels every 1000 data points
            if(count ==1000)
            {
               System.err.println();          
               count = 0;
               s2 = true;			
            }
         	
            cmin=snk.Fetch(600000);
	    // MJM 07/14/2005: Add check on number of channels
            if ((cmin.NumberOfChannels() > 0) && !cmin.GetIfFetchTimedOut()) 
            {
               index++;
               if(!s) System.out.println(index+" -Packet Recieved-, size: "+cmin.GetData(0).length);          	
               process(cmin);
	       System.err.print(".");

	   /*  flush inside process? mjm 9/05
               if (cmv!=null && cmv.size()>0) {
                  for (int i=0;i<cmv.size();i++) {
                     src.Flush((ChannelMap)cmv.get(i));
                  }
               } 
	    */
            } else System.err.print("x");
            
            s2 = false;
         }
      }
   
   	//-------------------------------------------------------------------------
   	//process data channels
       public void process(ChannelMap in) throws Exception {
                  
	 ChannelMap out = new ChannelMap();  
    	
         try {
	    if (in.GetIndex(In)!=0) return;
           
            byte[][] data=in.GetDataAsByteArray(0);
         	
       	//retrieving channel names&descriptions and marker (again, ugh)
            String []type = xml.getType();
            String []label = xml.getLabel();
	    String []id = xml.getID();
            String []info = xml.getInfo();
            String marker = xml.getMarker(); 
            int    lmarker = marker.length();
	    String cname = "";

            String cmarker  = marker.substring(0,Nmarker);  // for now, just blindly check first N chars
            System.err.println("Marker: "+marker+",lmarker: "+lmarker+", cmarker: "+cmarker);
            
         	//size of packet to be read	
            int size = xml.getSize();
            
            for (int i=0;i<data.length;i++) {

                if(data[i].length < lmarker) continue;  // can't be good
                String udpmarker = new String(data[i],0,Nmarker);
    
                if(!s) System.err.println
                  ("Want marker,size: "+cmarker+","+size+", Got: "+udpmarker+","+data[i].length);                                	
            	//reading data
		if (data[i].length==size && udpmarker.equals(cmarker)) {  // got a good UDP packet
		    //Starts reading after marker size
//		    ByteArrayInputStream bais = new ByteArrayInputStream(data[i],24,data[i].length);
		    ByteArrayInputStream bais = new ByteArrayInputStream(data[i],lmarker,data[i].length);
		    
		    double time=in.GetTimes(0)[i];  	// default = time data received
		    out.Clear();

		    System.err.println("nParam: "+xml.getNParam());
		    //processing of data channels
		    if(!multichan && (tstampField==0)) out.PutTime(time,0);  // one put of local time this case

		    for(int q=1; q<=xml.getNParam(); q++) {
			//create a new channel each time when in multiple mode              
			if(multichan)out.Clear();  // try clearing vs creating new (less GC?)
			
			if(label[q] == null) cname = id[q];
			else                 cname = label[q];
			cname=cname.replace('/', ' ');      //remove '/' from chan names (causes RBNB problems)          

			if(type[q].equals("double")) {
			    int idx = out.Add(cname);
			    byte[] eight=new byte[8];
			    bais.read(eight,0,8);     
			    double[] z=ByteConvert.byte2Double(eight,swapBytes);
			    
			    if(q==tstampField) {  // time presumed to be certain field & a double
				if(z[0] > 0.) time=z[0]; // use default local time if embedded time<=0
				else if(!s || s2) System.err.println
				    ("Warning, zero embedded time, using local time");
				if(roundtime==true) time = Math.round(time);
				if(!s|| s2) System.err.println("TIME: "+time);
				if(!multichan) out.PutTime(time,0);
			    }
			    if(!s|| s2) System.err.println("DATA["+q+"], "+cname+" "+z[0]);
			    if(multichan) out.PutTime(time,0.);
			    out.PutDataAsFloat64(idx,z);
			}
			
			if(type[q].equals("float")) {
			    int idx=out.Add(cname);
			    byte[] four=new byte[4];
			    bais.read(four,0,4);
			    float[] z=ByteConvert.byte2Float(four,swapBytes);
			    if(!s|| s2)
				System.err.println("DATA["+q+"], "+cname+" "+z[0]);
			    if(multichan) out.PutTime(time,0); // multichan -> put time every param
			    out.PutDataAsFloat32(idx,z);
			}   
			if(multichan) src.Flush(out);
		    }
		    
		    /* Latency channel */
		    if(multichan) out.Clear();
		    int idx = out.Add("_Latency");                  
		    double rtime = in.GetTimes(0)[i];               // time data recieved
		    //System.err.println("TIME: "+rtime);            
		    double lat[] = new double[1];            
		    lat[0] = rtime - time;    	       	 // recieved - sent
		    if(!s|| s2) System.err.println("Latency "+lat[0]);
		    out.PutDataAsFloat64(idx,lat);
		    if(multichan) src.Flush(out);
		}
            }
         } catch (Exception e) {
	     e.printStackTrace();
	     // return null;
	 }
	 
	 if(!multichan) src.Flush(out);  // flush multiplexed map once at end
	 if(!s) System.err.println("WROTE DATA");

         //return outv;
       } //end method process  
   	
   } //end class XMLDemux

