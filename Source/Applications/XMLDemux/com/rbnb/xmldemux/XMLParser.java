/*
Copyright 2007 Creare Inc.

Licensed under the Apache License, Version 2.0 (the "License"); 
you may not use this file except in compliance with the License. 
You may obtain a copy of the License at 

http://www.apache.org/licenses/LICENSE-2.0 

Unless required by applicable law or agreed to in writing, software 
distributed under the License is distributed on an "AS IS" BASIS, 
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
See the License for the specific language governing permissions and 
limitations under the License.
*/

	/* JPB 5-17-05
	*
	*	XML Parser
	*  
	*	For use with XMLDemux.
	*  Provides simple access for embedded <type>, <label> and <info> tags.
	*/

	/*
	*  Modified for new header format- 8,4,4,8
	*
	*
	*/
   
   package com.rbnb.xmldemux;
   
   import java.util.Vector;

   import javax.xml.parsers.DocumentBuilder; 
   import javax.xml.parsers.DocumentBuilderFactory;  
   import javax.xml.parsers.FactoryConfigurationError;  
   import javax.xml.parsers.ParserConfigurationException;
 
   import org.xml.sax.SAXException;  
   import org.xml.sax.SAXParseException;  

   import java.io.File;
   import java.io.IOException;

   import org.w3c.dom.Document;
   import org.w3c.dom.DOMException;
   import org.w3c.dom.Node;
   import org.w3c.dom.*;

public class XMLParser {
    static boolean DEBUG = false;
    
    static String type[];
    static String label[];
    static String info[];
    static String id[];
    static String marker;
    static int size;
    static int ArraySize = 16384;   // max arraySize
    static int nParam=0;
    static int nMarker=0;

    // An array of names for DOM node-types
    // (Array indexes = nodeType() values.)
    static final String[] typeName = {
	"none",
	"Element",
	"Attr",
	"Text",
	"CDATA",
	"EntityRef",
	"Entity",
	"ProcInstr",
	"Comment",
	"Document",
	"DocType",
	"DocFragment",
	"Notation",
	"parameter id",
    };
    
    //Constructor
    public XMLParser(org.w3c.dom.Node nodeI) {
	type = new String[ArraySize];        
	label = new String[ArraySize];        
	info = new String[ArraySize];   
	id   = new String[ArraySize];
	
	printNode(nodeI,"",false,"");
    }
    
    public XMLParser(String file) {
	marker = "";
	nMarker=0;
	nParam = 0;
	size = 0;
	
	DocumentBuilderFactory factory =
	    DocumentBuilderFactory.newInstance();
	
	try {
	    DocumentBuilder builder = factory.newDocumentBuilder();
	    Document document = builder.parse( new File(file) );
	    
	    // setLength(document);
	    new XMLParser(document);
	} 
	catch (SAXParseException spe) {
	    // Error generated by the parser
	    System.out.println("\n** Parsing error"
			       + ", line " + spe.getLineNumber()
			       + ", uri " + spe.getSystemId());
	    System.out.println("   " + spe.getMessage() );
	    
	    // Use the contained exception, if any
	    Exception  x = spe;
	    if (spe.getException() != null)
		x = spe.getException();
	    x.printStackTrace();
	} 
	catch (SAXException sxe) {
	    // Error generated during parsing)
	    Exception  x = sxe;
	    if (sxe.getException() != null)
		x = sxe.getException();
	    x.printStackTrace();	    
	} 
	catch (ParserConfigurationException pce) {
	    // Parser with specified options can't be built
	    pce.printStackTrace();
	    
	} 
	catch (IOException ioe) {
	    // I/O error
	    ioe.printStackTrace();
	}
    }// end Constructor
    
	//************************************* 
	/* 	
	 *  Main for testing purposes
	 */  
	public static void main(String argv[]) {
	    XMLParser c = new XMLParser(argv[0]);
	    	    
	    for(int i=0; i<nParam; i++) {
		System.out.println(type[i]+"\t"+label[i]+"\t"+info[i]);
		//System.out.println();
		//System.out.println();
		//System.out.println("*");
	    }
	    
	    //System.out      
	    System.out.println("Channels: "+(nParam));
	    System.out.println("Marker: "+marker);
	    System.out.println("Size: "+size);
	    System.out.println("Label.length()"+label.length);
	    marker  = marker.substring(0,16);
	    System.out.println(marker);
	} // end main
	
   	
	//*************************************  	
	/*
	 * Recursively check all nodes.  When the parameter tag is encountered, 
	 * pull out <type>, <label> and <info> tags.
	 *
	 */        
	private void printNode(org.w3c.dom.Node nodeI, String prefix, boolean b, String str) {
	    String temp = nodeI.getNodeName();      

	    if(temp.equals("parameter")) {
		nParam++;
		
		org.w3c.dom.NamedNodeMap na=nodeI.getAttributes();
		org.w3c.dom.Node nid = na.getNamedItem("id");
		id[nParam] = nid.getNodeValue();
		//		System.err.println("nParam: "+nParam+", id: "+id[nParam]);

		org.w3c.dom.NodeList nodeList = nodeI.getChildNodes();
		for (int i=0; i<nodeList.getLength(); i++) {
		    org.w3c.dom.Node subnode = nodeList.item(i);
		    printNode (subnode, prefix + "...", true,"");
		}
	    }
	    
	    if(b) {
		if(nodeI.getNodeName().equals("#text")) {
		    if (str.equals("type")) {
			type[nParam] = nodeI.getNodeValue().trim();
			if(nodeI.getNodeValue().trim().equals("double"))
			    size+=8;
			if(nodeI.getNodeValue().trim().equals("float"))
			    size+=4;
		    }
               	
		    if(str.equals("label")) {
			label[nParam] = nodeI.getNodeValue().trim();
			//System.err.println("label["+nParam+"]: "+label[nParam]);
		    }

		    if(str.equals("info"))
			info[nParam] = nodeI.getNodeValue().trim();
		    
		    if(str.equals("format")) {  // this is a marker
			marker = marker+nodeI.getNodeValue().trim();	// concatenates markers
			size+=nodeI.getNodeValue().trim().length();
			nParam--;
                        nMarker++;
		    }
		}  
         	
		//process all nodes
		if (nodeI.getNodeType() == Node.ELEMENT_NODE) {
		    //System.err.println( prefix + "node attributes: length = " + nodeI.getAttributes().getLength());
		    for (int i=0; i<nodeI.getAttributes().getLength(); ++i) {
			//System.err.println( prefix + "Item " + i + ":\n" + prefix + "<<<<<");
			printNode(nodeI.getAttributes().item(i), prefix + "---",false, nodeI.getNodeName());
			//System.err.println(prefix + ">>>>>");
		    }
		}
	    }
	    
	    //process all nodes
	    org.w3c.dom.NodeList nodeList = nodeI.getChildNodes();
	    for (int i=0; i<nodeList.getLength(); i++) {
		org.w3c.dom.Node subnode = nodeList.item(i);
		printNode(subnode, prefix + "...",b,nodeI.getNodeName());
	    }
	    
	}
	
   	//--------------------------------------------------------------------
   	//get Methods
	public String[] getType(){
	    return type;}
	public String[] getInfo(){
	    return info;}
	public String[] getLabel(){
	    return label;}
	public int getSize(){
	    return size;}
	public String getMarker(){
	    return marker;}
	public String[] getID() {
	    return id; }
	public int getNParam() {
	    return nParam; }
	
    }


