import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
//import java.awt.image.renderable.ParameterBlock;
import java.io.ByteArrayOutputStream;
import java.util.Hashtable;
import java.util.Stack;

//import javax.media.jai.JAI;
//import javax.media.jai.RenderedOp;	// mjm 5/04

import com.rbnb.plot.Channel;
import com.rbnb.plot.DataTimeStamps;
import com.rbnb.plot.Environment;
import com.rbnb.plot.LayoutCubby;
import com.rbnb.plot.PlotContainer;
import com.rbnb.plot.PosDurCubby;
import com.rbnb.plot.RegChannel;
import com.rbnb.plot.Time;

import com.rbnb.sapi.*;

import com.rbnb.utility.ArgHandler;

/**
  * SAPI PlugIn to convert RBNB channel data to a PNG format. 
  * <p>
  * @author Bill Finger
  * @since V2.0
  * @version 2004/08/11
  */
  
 /*
 * Copyright 2004 Creare Inc.
 * All Rights Reserved.
 *
 *   Date      By   Description
 * MM/DD/YYYY
 * ----------  --   -----------
 * 02/11/2002  WHF  Created.
 * 02/22/2002  WHF	Handles requests for "...", which return EndOfStream.
 * 04/16/2002  WHF  Handles requests for registration
 * 05/16/2002  WHF  Passes through requests for registration that are not "...".
 * 05/22/2002  WHF  Removed references to deprecated items.
 * 11/14/2002  WHF  Returns data as a ByteArray instead of Int8.
 * 11/15/2002  WHF  Fixed some bugs in synchronization.
 * 01/22/2003  WHF  Incorporated server-side meta-data kluge here.
 * 2004/08/11  WHF  Switched from JAI to javax.imageio, which comes with JVM 1.4
 * 2006/10/19  EMF  Modified PNG drawing to eliminate dead space from Frame borders.
 * 2006/10/19  EMF  Pulled Sink connection out of individual threads, so now shared
 *                  but saves lots of connect calls which are slow.
 */
 
public class PNGPlugIn implements Runnable
{
	public static void main(String[] args)
	{	
		ArgHandler ah=null;
		try {
		ah=new ArgHandler(args);
		} catch (Exception e) { showUsage(); }
		
		if (ah.getOption('?')!=null)
			showUsage();

		PNGPlugIn pi=new PNGPlugIn();
		pi.setHostName(ah.getOption('a',"localhost:3333"));
		pi.setClientName(ah.getOption('n',"PNGPlugIn"));
		pi.setWidth(Integer.parseInt(ah.getOption('w',"320")));
		pi.setHeight(Integer.parseInt(ah.getOption('h',"200")));
		
		pi.run();
	}
	
	private static void showUsage()
	{
		System.err.println(PNGPlugIn.class.getName()
			+": Converts RBNB channels to PNG (Portable Network"
			+" Graphics) files.\nCopyright Creare, Inc. 2004"
			+"\nOptions:"
			+"\n\t-a host:port [localhost:3333]\t- RBNB server"
				+" to connect to"
			+"\n\t-n name [PNGPlugIn]\t- client name for plugin"
			+"\n\t-w width [320]\t- Width of produced image, pixels"
			+"\n\t-h height [200]\t- Height of image, pixels");
		System.exit(1);
	}
	
	/**
	  * Constructor.
	  */
	public PNGPlugIn()
	{ 
		pi=new PlugIn();
		map=new PlugInChannelMap();
		threadStack=new Stack();
	}
	
	public void setHostName(String host) { this.host=host; }
	public void setClientName(String name) { this.name=name; }
	public void setWidth(int width) { this.width=width; }
	public void setHeight(int height) { this.height=height; }
	
	private synchronized void requestFetch(ChannelMap cm, double start,
	                                       double duration, String ref)
	    {
		try {
		if (!sink.VerifyConnection()) {
		    sink.CloseRBNBConnection();
		    sink.OpenRBNBConnection(host,name+"Sink");
		}
		sink.Request(cm,start,duration,ref);
		sink.Fetch(60000,cm); // bump timeout 10->60? mjm
		} catch (Exception e) {
		    System.err.println("PNGPlugIn.requestFetch exception");
		    e.printStackTrace();
		}
	    }
	
	public void run()
	{
	    //EMF 10/13/06: get frame insets so graphics context is appropriately sized
	    java.awt.Frame fr=new java.awt.Frame();
	    fr.setBounds(-1000,-1000,320,200);
	    fr.setVisible(true);
	    insets=fr.getInsets();
	    fr.setVisible(false);
	    fr.dispose();
	    
		try {
		pi.OpenRBNBConnection(host,name);
		sink=new Sink();
		sink.OpenRBNBConnection(host,name+"Sink");
		
		while (true)
		{
// mjm 3/13/02: following causes infinite loop when socket closed by admin (ouch)
//		try {
			// The long wait was due to the synchronization on the Flush, and
			//  a bug in the full api plugin code.
//		    pi.Fetch(100,map); // (100->10000 NG) if this timeout is 10sec, it slows down?? mjm
			pi.Fetch(-1,map);
//			if (map.NumberOfChannels()>0) registration requests can have no chan
			if (!map.GetIfFetchTimedOut())
			{
//System.err.println("Got \""+map.GetRequestReference()+"\"request for:\n"+map);
				AnswerRequest a;
				if (threadStack.empty())
					a=new AnswerRequest();
				else
					a=(AnswerRequest) threadStack.pop();
				a.setRequestMap(map);
				new Thread(a).start();
				map=new PlugInChannelMap(); // use new map
			}
//		} catch (SAPIException se) { se.printStackTrace(); }
		}

		// Outer try.  If we can't connect the PlugIn, there's no 
		//  point in continuing.
		} catch (SAPIException se) { se.printStackTrace(); }
	}

	////////////////// Private methods/classes ///////////////////////////
	private class AnswerRequest implements Runnable
	{
		AnswerRequest() 
		{		
			//sink=new Sink();
			sinkMap=new ChannelMap();
			
			// Neither RegChannel nor PDC have
			//  any lasting effect on the component:
			PosDurCubby posdur = new PosDurCubby();
			posdur.setTimeFormat(Time.RelativeSeconds);
			plotter=new PlotContainer(
				new RegChannel(""),
				LayoutCubby.PlotMode,
				posdur,
				env=new Environment(),
				true);	//EMF 10/12/06: true means show title
			chan=new Channel();
			configHash=new Hashtable();
			frame=new java.awt.Frame();
			frame.setBounds(-1000,-1000,
				width+insets.left+insets.right,
				height+insets.top+insets.bottom);
			frame.add(plotter);

			baos=new ByteArrayOutputStream();
			/*pb = new ParameterBlock();
			pb.add(baos);           // The stream
			pb.add("png");		// file format
			pb.add(null);           // Encoding parameters
			*/
		}
		
		public void setRequestMap(PlugInChannelMap requestMap)
		{ this.requestMap=requestMap; }
		
		public void run()
		{
			try {	
			    //EMF 10/12/06: pull out message
			    configHash.put("scaling","auto_inc_dec");
			    String[] message=null;
			    //System.err.println("requestMap.GetType(0) "+requestMap.GetType(0));
			    if (requestMap.GetType(0)==ChannelMap.TYPE_STRING) {
				message = requestMap.GetDataAsString(0);
			    } else if (requestMap.GetType(0)==ChannelMap.TYPE_INT8) {
				message=new String[1];
				message[0]=new String(requestMap.GetDataAsInt8(0));
			    }
//System.err.println("requestMap(0) contained message "+message[0]);
			    if (message!=null && message[0].trim().length()>0) {
				message[0]=message[0].trim();
				char[] term = {'&'};
				com.rbnb.utility.KeyValueHash kvh=new com.rbnb.utility.KeyValueHash(message[0],term);
				String div=kvh.get("png_div");
				if (div==null) div=new String("8");
				String min=kvh.get("png_min");
				String max=kvh.get("png_max");
//System.err.println("div="+div+", min="+min+", max="+max);
				if (min!=null && max!=null) {
				    configHash.put("scaling","manual");
				    configHash.put("divisions",div);
				    configHash.put("min",min);
				    configHash.put("max",max);
				}
			    }
			// Check for registration map query:
			
			// Old style query:
//			if (!(requestMap.NumberOfChannels()==1
//				&&requestMap.GetName(0).equals("...")))
			// New method:
			boolean registrationRequest="registration".equals(
				requestMap.GetRequestReference());
			if (!(registrationRequest && requestMap.NumberOfChannels()==0
				||requestMap.NumberOfChannels()==1  // old style reg request
					&&requestMap.GetName(0).equals("...")))
			{ // fill in map:
			//sink.OpenRBNBConnection(host,name+"Sink");
			
			// Get original data:
			for (int ii=0; ii<requestMap.NumberOfChannels(); ++ii)
				sinkMap.Add(requestMap.GetName(ii));
			
			requestFetch(sinkMap,
				requestMap.GetRequestStart(),
				requestMap.GetRequestDuration(),
				requestMap.GetRequestReference()
				// ,requestMap.IsRequestFrames() whf 05/22/2002
				);
			//EMF 10/13/06: use separate map, so can make empty plots
			ChannelMap sinkMapI=null;
			//sink.Fetch(60000,sinkMap); // bump timeout 10->60? mjm

			if (sinkMap.GetIfFetchTimedOut())
				System.err.println("++ PNGPlugIn Time out on"
					+requestMap.GetName(0));
			
			for (int ii=0; ii<sinkMap.NumberOfChannels(); ++ii)
			{
				double plotduration;
				double plotstart;


				int rIndex=requestMap.GetIndex(
					sinkMap.GetName(ii));					

				if (rIndex==-1) // channel does not exist 
				// in request, add it
					rIndex=requestMap.Add(sinkMap
						.GetName(ii));

				if (registrationRequest)
				{
					requestMap.PutTimeRef(sinkMap,ii);
					if ("text/xml".equals(sinkMap.GetMime(ii)))
					{  // probably server meta-data, override
						String result=
							"<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n"
							+"<!DOCTYPE rbnb>\n"
							+"<rbnb>\n"
							+"\t\t<size>"+1+"</size>\n"
  							+"\t\t<mime>image/png</mime>\n"
							+"</rbnb>\n";
						requestMap.PutDataAsString(rIndex, result);
					}
					else
					requestMap.PutData(rIndex,sinkMap.GetData(ii),
							sinkMap.GetType(ii));
					requestMap.PutMime(rIndex,sinkMap.GetMime(ii));
				} else {
					
				byte[] out=null;
				String mimeStr="image/png";
//				int type=ChannelMap.TYPE_INT8;
				int type=ChannelMap.TYPE_BYTEARRAY;

				// Convert to PNG:
				try {
				fillChannel(sinkMap,ii,chan);
				//EMF 10/16/06: following lines instead of fillChannel
				//              will create png with no data
				//chan.clear();
				//chan.channelName=sinkMap.GetName(ii);
				plotduration = requestMap.GetRequestDuration();
				double[] times=sinkMap.GetTimes(ii);
				//EMF 10/17/06: appropriate position data within plot
				if (times.length>0 && requestMap.GetRequestReference().equalsIgnoreCase("newest")) {
				    plotstart=times[times.length-1] - plotduration;
				} else if (requestMap.GetRequestReference().equalsIgnoreCase("oldest")) {
				    plotstart=times[0];
				} else {
				    plotstart=requestMap.GetRequestStart();
				}
				  
				  /* whf 05/22/2002  byFrame deprecated, always use request 
				   duration
				// mjm 3/20/02:  use request duration for Time request
				if(requestMap.IsRequestFrames()) 
				    plotduration = times[times.length-1]-times[0]
					+(times.length>1?times[1]-times[0]
					:0.0); // can't plot 1 pt anyway
				 else
				*/
				

				out=convertToPNG(
					sinkMap.GetName(ii),
					times,
					plotstart,
					plotduration,
					sinkMap.GetType(ii));
				} catch (IllegalArgumentException iae)
				{
					iae.printStackTrace();
					// most likely the PNG converter
					//  couldn't convert with the current
					// display settings.
					out=("<HTML><TITLE>PNGPlugIn Error"
					+"</TITLE><BODY><h1>PNGPlugIn Error"
					 +"</h1><p>The data provided was " 
					 +"plotted but could not be converted " 
					 +"to a PNG.&nbsp; Be sure the " 
					 +"webserver "
					 +"machine has at least 32 bit color "
					 +"on its display."
					 +"</BODY></HTML>\n").getBytes();
					mimeStr="text/html";
					type=ChannelMap.TYPE_STRING;
				}					 
				catch (ClassCastException iae)
				{ 
					iae.printStackTrace();
					// we have an unsupported type.  Return 
					//  an HTML document to that effect.
					out=("<HTML><TITLE>PNGPlugIn Error"
					 +"</TITLE><BODY><h1>PNGPlugIn Error"
					 +"</h1><p>The data type \""
					 +sinkMap.TypeName(sinkMap.GetType(ii))
					 +"\", for channel "
					 +"<b>"+sinkMap.GetName(ii)+"</b>, "
					 +"cannot be converted to a Portable"
					 +" Network Graphic.</p>"
					 +"</BODY></HTML>\n").getBytes();
					mimeStr="text/html";
					type=ChannelMap.TYPE_STRING;
				}					 
				catch (java.io.IOException ioe)
				{ 
					ioe.printStackTrace();
					// we have an unsupported type.  Return 
					//  an HTML document to that effect.
					out=("<HTML><TITLE>PNGPlugIn Error"
					 +"</TITLE><BODY><h1>PNGPlugIn Error"
					 +"</h1><p>A problem occurred while generating the image"
					 +" for channel <b>"+sinkMap.GetName(ii)+"</b>.</p>"
					 +"</BODY></HTML>\n").getBytes();
					mimeStr="text/html";
					type=ChannelMap.TYPE_STRING;
				}
					
				// Set time on map:
				requestMap.PutTime(
					sinkMap.GetTimeStart(ii),
					sinkMap.GetTimeDuration(ii));
					
				// Put PNG into output map:
				requestMap.PutData(
					rIndex,
					out,
					type,
					ChannelMap.MSB);
				requestMap.PutMime(rIndex,mimeStr);
				} // end else
			} // end for

			sinkMap.Clear();
			//sink.CloseRBNBConnection();
			} // return either filled in map or nothing
			else requestMap.Clear();
//			synchronized (pi)
//			{
				pi.Flush(requestMap,false);
//			}
			} catch (SAPIException se) { se.printStackTrace(); }
			// Request done, push us back onto the stack:
			threadStack.push(this);
		} // end AnswerRequest.run()
		
		private byte[] convertToPNG(
			String name,
			double[] times,
			double start,
			double duration,
			int type) throws java.io.IOException
		{
			// Set up plotting sub-component:
			env.FOURBYTEASINTEGER=
				((type==ChannelMap.TYPE_INT16||type==ChannelMap.TYPE_INT8)?
				true:false);			

			// Set the plot's title:
			configHash.put("name",name);

			plotter.setConfig(configHash,"");
			plotter.setAbscissa(new Time(duration)); 
			plotter.setChannelData(chan,new Time(start));  
			//plotter.setChannelData(chan,new Time(times[0]));  
			
			// Produce Image:
			int w=width, h=height;

//			frame.addNotify();  doesn't work.
			frame.setVisible(true);
			java.awt.Image img=plotter.createImage(w,h);
			java.awt.Graphics gi=img.getGraphics();
			plotter.paint(gi);
			frame.setVisible(false);
//			frame.removeNotify();
			baos.reset();						
// mjm 5/04:  use buffered (rendered) image, works without Xlib,
// faster non-munged on new sdp 
			// 2004/08/11  WHF  use javax.imageio as opposed to JAI:
			//RenderedOp bimg = JAI.create("AWTImage", img);
			//pb.setSource(bimg,0);   // The source image			
//			pb.setSource(img,0);   // The source image			
			
			// Perform the encode operation
//			JAI.create("encode", pb, null);
				
			javax.imageio.ImageIO.write(
					(java.awt.image.RenderedImage) img,
					"png",
					baos
			);

			return baos.toByteArray();
		}
		
		///////// AnswerRequest Private Data /////////////
		//private final Sink sink;
		private PlugInChannelMap requestMap;
		private final ChannelMap sinkMap;

		// Objects in plot package used for preparing graphs:
		private final Hashtable configHash;
		private final PlotContainer plotter;
		private final Environment env;
		private final Channel chan;
		
		// Objects used to turn plot into bytes:
//		private final ParameterBlock pb;
		private final ByteArrayOutputStream baos;
		private final java.awt.Frame frame;
		
	} // end inner class AnswerRequest
	
	private static void fillChannel(ChannelMap map,int ii,Channel chan)
	{
		int typecode=map.GetType(ii);
		chan.clear();
		
		chan.channelName=map.GetName(ii);

		// As of 02/12/2002, ignored in channel:
		chan.byteOrder=Channel.MSB; 

		chan.timeStamp=new DataTimeStamps(map.GetTimes(ii));		
		
		switch (typecode)
		{
			case ChannelMap.TYPE_FLOAT64:
				chan.setDataFloat64(map.GetDataAsFloat64(ii));
				break;

			case ChannelMap.TYPE_FLOAT32:
				chan.setDataFloat32(map.GetDataAsFloat32(ii));
				break;

			case ChannelMap.TYPE_INT32:
				chan.setDataInt32(map.GetDataAsInt32(ii));
				break;

			case ChannelMap.TYPE_INT16:
				chan.setDataInt16(map.GetDataAsInt16(ii));
				break;
				
			case ChannelMap.TYPE_INT8:
				chan.setDataInt8(map.GetDataAsInt8(ii));
				break;
				
			case ChannelMap.TYPE_INT64:
				chan.setDataInt64(map.GetDataAsInt64(ii));
				break;				

			default:
				throw new ClassCastException(
					"Unsupported type.");
		}
	}
	
	////////////////// Private data /////////////////////////////
	private int width, height;
	private String host, name;
	private final PlugIn pi;
	private PlugInChannelMap map;
	private Stack threadStack;
	private java.awt.Insets insets;
	private Sink sink;
}

