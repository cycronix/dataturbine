//KMLiPlugIn - creates a kmz file containing a kml and multiple dae documents
//             with network links to images, for dynamic display in Google
//             Earth beta4 and newer clients
// Eric Friets
// 10/18/06
// for SecureScan

// direct descendent of the KMLiPlugIn code

import com.rbnb.sapi.ChannelMap;
import com.rbnb.sapi.PlugIn;
import com.rbnb.sapi.PlugInChannelMap;
import com.rbnb.sapi.Sink;
import com.rbnb.utility.ArgHandler;
import com.rbnb.utility.KeyValueHash;
import com.rbnb.utility.RBNBProcess;

import java.io.ByteArrayOutputStream;
import java.util.Hashtable;
import java.util.zip.Deflater;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

public class KMLitPlugIn {

//RBNB connections
private String address = "localhost:3333";
private String sinkName = "kmlitSink";
private String pluginName = "KMLit";
private Sink sink = null;
private PlugIn plugin = null;

private double baseinterval=1;
private int basecount=100; //20;
private String urlBase="http://localhost/RBNB/";

public static void main(String[] args) {
    (new KMLitPlugIn(args)).exec();
}

//constructor
public KMLitPlugIn(String[] args) {
    
    //parse args
    try {
	ArgHandler ah = new ArgHandler(args);
	
	// 'h' Help
	if (ah.checkFlag('h')) {
	    System.err.println("KMLitPlugIn command line options");
	    System.err.println("   -a <RBNB address>");
	    System.err.println("       default: localhost:3333");
	    System.err.println("   -c <count> : max number of images to return");
	    System.err.println("      default: 100");
	    System.err.println("   -h (display this help message)");
	    System.err.println("   -i <interval> : min interval between images");
	    System.err.println("      default: 1 second");
	    System.err.println("   -n <PlugIn name>");
	    System.err.println("       default: KMLit");
	    System.err.println("   -u <URL base> : beginning of image URLs");
	    System.err.println("       default: http://localhost/RBNB/");
	}
	
	// 'a' - RBNB server address
	if (ah.checkFlag('a')) {
	    String addressL = ah.getOption('a');
	    if (addressL != null) {
		address=addressL;
	    } else {
		System.err.println(
		    "WARNING: Null argument to the \"-a\"" +
		    " command line option.");
	    }
	}
	
	// 'c' - count
	if (ah.checkFlag('c')) {
	    String countS = ah.getOption('c');
	    if (countS!=null) {
		basecount = Integer.parseInt(countS);
	    } else {
		System.err.println("WARNING: Null argument to the -c command line option");
	    }
	}
	
	// 'i' - interval
	if (ah.checkFlag('i')) {
	    String intervalS = ah.getOption('i');
	    if (intervalS!=null) {
		baseinterval = Double.parseDouble(intervalS);
	    } else {
		System.err.println("WARNING: Null argument to the -i command line option");
	    }
	}
	
	// 'n' PlugIn name
	if (ah.checkFlag('n')) {
	    String name = ah.getOption('n');
	    if (name != null) {
		pluginName = name;
	    } else {
		System.err.println(
		    "WARNING: Null argument to the \"-n\"" +
		    " command line option.");
	    }
	}
	
	// 'u' URL base
	if (ah.checkFlag('u')) {
	    String urlL=ah.getOption('u');
	    if (urlL!=null) {
		urlBase=urlL;
	    } else {
		System.err.println("WARNING: Null argument to the \"-u\" command line option");
	    }
	}
    } catch (Exception e) {
	System.err.println("AppendPlugIn argument exception "+e.getMessage());
	e.printStackTrace();
	RBNBProcess.exit(0);
    }
} //end constructor

//main execution loop
// creates plugin and sink connections, handles picm requests
public void exec() {
    
    //open connections
    try {
	sink = new Sink();
	sink.OpenRBNBConnection(address,sinkName);
	plugin = new PlugIn();
	plugin.OpenRBNBConnection(address,pluginName);
    } catch (Exception e) {
	System.err.println("Exception opening RBNB connections, aborting.");
	e.printStackTrace();
	RBNBProcess.exit(0);
    }
    
    //warn user if plugin name is different
    // (probably means another version of AppendPlugIn is running...)
    if (!plugin.GetClientName().equals(pluginName)) {
	pluginName = plugin.GetClientName();
	System.err.println(
	    "WARNING: The actual PlugIn name is " +
	    pluginName);
    }
    System.err.println("connections open; awaiting requests");
    
    //loop handling requests
    while (true) {
	PlugInChannelMap picm = null;
	try {
	picm = plugin.Fetch(3000);

	if ((picm.GetIfFetchTimedOut())||
	    (picm.NumberOfChannels()==0)) continue;
	
	//if generic registration request, just return
//	if (picm.GetRequestReference().equals("registration") &&
//	(picm.GetName(0).equals("*")||picm.GetName(0).equals("..."))) {
//	    plugin.Flush(picm);
//	    continue;
//	}
System.err.println("\npicm "+picm);
System.err.println("start "+picm.GetRequestStart()+", dur "+picm.GetRequestDuration()+", ref "+picm.GetRequestReference());
//byte[] foo=picm.GetDataAsInt8(0);
//System.err.println("foo length "+foo.length);
//for (int i=0;i<foo.length;i++) System.err.println(foo[i]);

	String[] message=null;
//System.err.println("picm.GetType(0) "+picm.GetType(0));
	if (picm.GetType(0)==ChannelMap.TYPE_STRING) {
	    message = picm.GetDataAsString(0);
	} else if (picm.GetType(0)==ChannelMap.TYPE_INT8) {
	    message=new String[1];
	    message[0]=new String(picm.GetDataAsInt8(0));
	}
System.err.println("picm(0) contained message "+message[0]);
	int count=basecount;
	double interval=baseinterval;
	if (message!=null && message[0].trim().length()>0) {
	    message[0]=message[0].trim();
	    char[] term = {'&'};
	    KeyValueHash kvh=new KeyValueHash(message[0],term);
	    String countS=kvh.get("kmlit_count");
	    String intervalS=kvh.get("kmlit_interval");
	    if (countS!=null) try {
		count=Integer.parseInt(countS);
	    } catch (Exception e) { e.printStackTrace(); }
	    if (intervalS!=null) try {
		interval=Double.parseDouble(intervalS);
	    } catch (Exception e) { e.printStackTrace(); }
	    
System.err.println("message contained count="+countS+", interval="+intervalS);
System.err.println("  new count="+count+", interval="+interval);
	}

	
	//make registration request, get data limits
	ChannelMap cm = new ChannelMap();
	for (int i=0;i<picm.NumberOfChannels();i++) cm.Add(picm.GetName(i));
System.err.println("created cm "+cm);
	if (message!=null && message[0].length()>0) for (int i=0;i<cm.NumberOfChannels();i++) cm.PutDataAsString(i,message[0]);
// System.err.println("making request with cm "+cm);
	sink.RequestRegistration(cm);
	cm=sink.Fetch(60000);
System.err.println("return ChannelMap from fetch:\n" + cm);
	if (cm.GetIfFetchTimedOut()) {
	    System.err.println("timed out making request, returning no data");
	    plugin.Flush(picm);
	    continue;
	}
	if (cm.NumberOfChannels()<1) {
	    System.err.println("no data on requested channel, returning no data");
	    plugin.Flush(picm);
	    continue;
	}
System.err.println("cm(0) range "+cm.GetTimeStart(0)+" plus "+cm.GetTimeDuration(0));
	
	//find appropriate begin and end of images
	double begin=0;
	double end=0;
	double duration=cm.GetTimeDuration(0);
	if (duration>picm.GetRequestDuration()) duration=picm.GetRequestDuration();
	if (picm.GetRequestReference().equals("registration")) {
	    picm.PutTime(cm.GetTimeStart(0),cm.GetTimeDuration(0));
	    picm.PutDataAsInt8(0,new byte[1]);
	    plugin.Flush(picm);
	    continue;
	} else if (picm.GetRequestReference().equals("newest")) {
	    end=cm.GetTimeStart(0) + cm.GetTimeDuration(0);
	    begin=end-duration;
System.err.println("newest req, begin="+begin+", dur="+duration+", end="+end);
	} else if (picm.GetRequestReference().equals("oldest")) {
	    begin=cm.GetTimeStart(0);
	    end=begin+duration;
System.err.println("oldest req, begin="+begin+", dur="+duration+", end="+end);
	} else { //must be absolute request
	    begin=cm.GetTimeStart(0);
	    if (begin<picm.GetRequestStart()) begin=picm.GetRequestStart();
	    end=begin+duration;
	    double dataend=cm.GetTimeStart(0)+cm.GetTimeDuration(0);
	    double reqend=picm.GetRequestStart()+picm.GetRequestDuration();
	    if (end>dataend) end=dataend;
	    if (end>reqend) end=dataend;
	    duration=end-begin;   // mjm was begin-end
System.err.println("absolute req, begin="+begin+", dur="+duration+", end="+end);
	}
	
	//find times of images to request
System.err.println("count="+count+", interval="+interval);
	if (duration<=0) count=1;
	else if (duration/count < interval)  count=(int)Math.round(duration/interval);
	interval=duration/count;
System.err.println("count="+count+", interval="+interval);

	//10/26/06 EMF : first pass at dynamic image placement
	//fetch zoom factor
	/*cm.Clear();
	cm.Add("zoom/"+picm.GetName(0));
	sink.Request(cm,0,0,"newest");
	cm=sink.Fetch(2000);
	float zoom=1; //sane default, I guess
	if (cm.NumberOfChannels()>0) { //needs some firewalls...
	    zoom=cm.GetDataAsFloat32(0)[0];
	} else System.err.println("NO ZOOM CHANNEL FOUND");
	System.err.println("zoom="+zoom);*/
	
	
	//create KML string
	byte[] zip = buildKMZ(urlBase+picm.GetName(0),begin,end,interval,count,picm.GetName(0));
//System.err.println("kmlString "+kmlString);
	if (zip!=null) {
    		picm.PutTime(begin,duration);
		picm.PutDataAsByteArray(0,zip);
	}
	plugin.Flush(picm);
	} catch (Exception e) {
	    System.err.println("RBNB exception; returning no data; restarting plugin and sink");
	    e.printStackTrace();
	    try {
		if (picm!=null) {
		    picm.Clear();
		    plugin.Flush(picm);
		}
		sink.CloseRBNBConnection();
		sink.OpenRBNBConnection(address,sinkName);
		plugin.CloseRBNBConnection();
		plugin.OpenRBNBConnection(address,pluginName);
	    } catch (Exception e2) {
		System.err.println("RBNB exception; unable to establish connections; aborting");
		e2.printStackTrace();
		break;
	    }
	}
    } //end while
} //end method exec

private byte[] buildKMZ(String url, double begin, double end, double intv, int cnt, String imgname) {
    ByteArrayOutputStream baos=new ByteArrayOutputStream();
    StringBuffer sb;
    String kmls; //kml string
    String places; //placemark string
    String daes; //dae string
    
    
    java.text.SimpleDateFormat sdf=new java.text.SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
    sdf.setTimeZone(new java.util.SimpleTimeZone(0,"UTC"));
    
    //load template files
    try {
	String line;
	sb=new StringBuffer();
	java.io.File file=new java.io.File("KMLitResources/kml.kml");
	java.io.FileReader fr=new java.io.FileReader(file);
	java.io.BufferedReader br=new java.io.BufferedReader(fr);
	while ((line=br.readLine())!=null) sb.append(line).append('\n');
	kmls=sb.toString();
	
	sb=new StringBuffer();
	file=new java.io.File("KMLitResources/placemark.kml");
	fr=new java.io.FileReader(file);
	br=new java.io.BufferedReader(fr);
	while ((line=br.readLine())!=null) sb.append(line).append('\n');
	places=sb.toString();
	
	sb=new StringBuffer();
	file=new java.io.File("KMLitResources/collada.dae");
	fr=new java.io.FileReader(file);
	br=new java.io.BufferedReader(fr);
	while ((line=br.readLine())!=null) sb.append(line).append('\n');
	daes=sb.toString();
	
	//following depends on read(cb) call which is java 1.5 only...
	//java.nio.CharBuffer cb=java.nio.CharBuffer.allocate((int)kmlf.length());
	//kmlfr.read(cb);
	//cb.rewind();
	//String kmls=cb.toString();
//System.err.println("kmls="+kmls);
//System.err.println("places="+places);
//System.err.println("daes="+daes);
    } catch (Exception e) {
	e.printStackTrace();
	return null;
    }
    
    //set up to get zoom factor

    ChannelMap cm=new ChannelMap();
    ChannelMap cmin=null;
    try {
	cm.Add("zoom/"+imgname);
    } catch (Exception e) {
	e.printStackTrace();
    }
    
    //set up zip file
    try {
	String[] daedoc=new String[cnt];
	//add placemarks to kml document, links to dae documents
	for (int i=0;i<cnt;i++) {
	    double btime=begin+i*intv;
	    double etime=begin+(i+1)*intv;
	    String bdate=sdf.format(new java.util.Date((long)btime*1000));
	    String edate=sdf.format(new java.util.Date((long)etime*1000));
	    
	    //get zoom factor
	    sink.Request(cm,btime,0,"absolute");
	    cmin=sink.Fetch(2000);
	    float zoom=1; //sane default, I guess
	    if (cmin.NumberOfChannels()>0) { //needs some firewalls...
		zoom=cmin.GetDataAsFloat32(0)[0];
	    }
	    System.err.println("zoom="+zoom);
	    
	    daedoc[i]=daes.replaceFirst("##href-jpg##",url+"?t="+btime);
	    String pm=places.replaceFirst("##id##","pm"+i);
	    pm=pm.replaceFirst("##name##","dae"+i+".dae");
	    pm=pm.replaceFirst("##begin##",bdate);
	    pm=pm.replaceFirst("##end##",edate);
	    pm=pm.replaceAll("##zoom##",Float.toString(zoom));
	    pm=pm.replaceFirst("##href-dae##","dae-"+i+".dae");
	    kmls=kmls.replaceFirst("##placemark##",pm+"##placemark##");
	}
	kmls=kmls.replaceFirst("##placemark##","");
	
	//zip it up

	ZipOutputStream zos=new ZipOutputStream(baos);
	zos.setMethod(ZipOutputStream.DEFLATED);
	zos.setLevel(Deflater.DEFAULT_COMPRESSION);
	ZipEntry ze=new ZipEntry("foo.kml");
	zos.putNextEntry(ze);
	byte[] data=kmls.getBytes();
	zos.write(data,0,data.length);
	zos.closeEntry();
	for (int i=0;i<cnt;i++) {
	    ze=new ZipEntry("dae-"+i+".dae");
	    zos.putNextEntry(ze);
	    data=daedoc[i].getBytes();
	    zos.write(data,0,data.length);
	    zos.closeEntry();
	}
	zos.close();
    } catch (Exception e) {
	System.err.println("Exception zipping kml/dae documents");
	e.printStackTrace();
    }

    return baos.toByteArray();
}

} //end class KMLiPlugIn
