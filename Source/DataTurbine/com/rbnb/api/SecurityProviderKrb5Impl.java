/*
Copyright 2007 Creare Inc.

Licensed under the Apache License, Version 2.0 (the "License"); 
you may not use this file except in compliance with the License. 
You may obtain a copy of the License at 

http://www.apache.org/licenses/LICENSE-2.0 

Unless required by applicable law or agreed to in writing, software 
distributed under the License is distributed on an "AS IS" BASIS, 
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
See the License for the specific language governing permissions and 
limitations under the License.
*/

package com.rbnb.api;

import com.rbnb.utility.Utility;

import org.ietf.jgss.GSSContext;
import org.ietf.jgss.GSSCredential;
import org.ietf.jgss.GSSManager;
import org.ietf.jgss.GSSName;
import org.ietf.jgss.Oid;

import java.awt.Container;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;

import java.awt.event.ActionListener;

import java.io.DataInputStream;
import java.io.DataOutputStream;

import java.security.PrivilegedExceptionAction;

import javax.security.auth.Subject;
import javax.security.auth.callback.*;
import javax.security.auth.login.LoginContext;

import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPasswordField;
import javax.swing.JTextField;

/**
  * Authentication via Kerberos V5 for RBNB.
  *
  * @author WHF
  * @version 2005/01/20
  * @since V2.5
  */

class SecurityProviderKrb5Impl implements SecurityProvider
{
	SecurityProviderKrb5Impl(TCP tcp)
	{
	    this.tcp = tcp;
	}

	/**
	  * Authenticates incoming data on the server.
	  */
	public void serverSideAuthenticate(
			java.io.InputStream is,
			java.io.OutputStream os) throws Exception
	{
		LoginContext lc = new LoginContext(
				this.getClass().getName()+".accept",
				new InternalCallbackHandler(tcp.getUsername())
		);
		
		lc.login();		
		
		final DataInputStream inStream = new DataInputStream(is);
		final DataOutputStream outStream = new DataOutputStream(os);

		Subject.doAs(
				lc.getSubject(),
				new PrivilegedExceptionAction() { 
			public Object run() throws Exception
			{
		GSSManager manager = GSSManager.getInstance();

		/*
		 * Create a GSSContext to receive the incoming request 
		 * from the client. Use null for the server credentials 
		 * passed in. This tells the underlying mechanism
		 * to use whatever credentials it has available that
		 * can be used to accept this connection.
		 */
		GSSContext context = manager.createContext((GSSCredential)null);

		// Do the context eastablishment loop
		
		byte[] token = null;
		
		while (!context.isEstablished()) {				
			token = new byte[inStream.readInt()];
/*			System.out.println("Will read input token of size "
							   + token.length
							   + " for processing by acceptSecContext"); */
			inStream.readFully(token);
			
			token = context.acceptSecContext(token, 0, token.length);
				
			// Send a token to the peer if one was generated by
			// acceptSecContext
			if (token != null && token.length != 0) {
/*				System.out.println("Will send token of size "
								   + token.length
								   + " from acceptSecContext."); */
				outStream.writeInt(token.length);
				outStream.write(token);
				outStream.flush();
			}
		}
					
		context.dispose();
		return null;
			}
		});
	}

	/**
	  * Authenticates incoming data on the client.
	  */
	public void clientSideAuthenticate(
			java.io.InputStream is,
			java.io.OutputStream os) throws Exception
	{
		if (tcp.getUsername() == null) tcp.setUsername(new Username());
		LoginContext lc = new LoginContext(
				this.getClass().getName()+".initiate",
				new InternalCallbackHandler(tcp.getUsername())
		);
		
		lc.login();		
		
		final DataInputStream inStream = new DataInputStream(is);
		final DataOutputStream outStream = new DataOutputStream(os);

		// This allows us to do the following under the login obtained above:
		Subject.doAs(
				lc.getSubject(),
				new PrivilegedExceptionAction() { 
			public Object run() throws Exception
			{
		GSSManager manager = GSSManager.getInstance();
		
		// Obtain a string which identifies the server.
		String target;
		try {
			target = System.getProperty("com.rbnb.api.Server.name");
		} catch (SecurityException se) { target = null; }
		if (target == null)
			target = "rbnb";

		/*
		 * Create a GSSName out of the server's name. The null
		 * indicates that this application does not wish to make
		 * any claims about the syntax of this name and that the
		 * underlying mechanism should try to parse it as per whatever
		 * default syntax it chooses.
		 */
		GSSName serverName = manager.createName(target, null);

		/*
		 * Create a GSSContext for mutual authentication with the
		 * server.
		 *	  - serverName is the GSSName that represents the server.
		 *	  - krb5Oid is the Oid that represents the mechanism to
		 *		use. The client chooses the mechanism to use.
		 *	  - null is passed in for client credentials
		 *	  - DEFAULT_LIFETIME lets the mechanism decide how long the
		 *		context can remain valid.
		 * Note: Passing in null for the credentials asks GSS-API to
		 * use the default credentials. This means that the mechanism
		 * will look among the credentials stored in the current Subject
		 * to find the right kind of credentials that it needs.
		 */
		GSSContext context = manager.createContext(
				serverName,
				krb5Oid,
				null,
				GSSContext.DEFAULT_LIFETIME);

		// Set the desired optional features on the context. The client
		// chooses these options.

		context.requestMutualAuth(false);  // Mutual authentication
		context.requestConf(false);	// Will use confidentiality later
		context.requestInteg(false); // Will use integrity later

		// Do the context eastablishment loop

		byte[] token = new byte[0];
		
		while (!context.isEstablished()) {

			// token is ignored on the first call
			token = context.initSecContext(token, 0, token.length);

			// Send a token to the server if one was generated by
			// initSecContext
			if (token != null) {
			/*	System.out.println("Will send token of size "
								   + token.length
								   + " from initSecContext.");  */
				outStream.writeInt(token.length);
				outStream.write(token);
				outStream.flush();
			}

			// If the client is done with context establishment
			// then there will be no more tokens to read in this loop
			if (!context.isEstablished()) {
				token = new byte[inStream.readInt()];
/*				System.out.println("Will read input token of size "
								   + token.length
								   + " for processing by initSecContext"); */
				inStream.readFully(token);
			}
		}
		
/*		System.out.println("Context Established! ");
		System.out.println("Client is " + context.getSrcName());
		System.out.println("Server is " + context.getTargName()); */

		//return context;
		context.dispose();
		return null;
			}
		});
			
	}	

// **************************  Data Members  ********************************//
	/**
	  * The TCP connection with which we are authenticating.
	  */
	private final TCP tcp;
	
	/**
	 * This Oid is used to represent the Kerberos version 5 GSS-API
	 * mechanism. It is defined in RFC 1964. We will use this Oid
	 * whenever we need to indicate to the GSS-API that it must
	 * use Kerberos for some purpose.
	 */
	private static final Oid krb5Oid;
	static {
		Oid temp;
		try {
			temp = new Oid("1.2.840.113554.1.2.2");
		} catch (org.ietf.jgss.GSSException gsse) { // should never occur
			temp = null;
		}
		krb5Oid = temp;
	}
	
} // end class SecurityProviderKrb5Impl

/**
  * Handles security callbacks requesting user interaction.
  */
class InternalCallbackHandler implements CallbackHandler
{
	public InternalCallbackHandler(Username un) { this.username = un; }
	
	/**
	  * @param callbacks The array of callbacks to handle.
	  */
	public void handle(Callback[] callbacks) throws java.io.IOException,
			UnsupportedCallbackException
	{
		for (int i = 0; i < callbacks.length; i++) {
			if (callbacks[i] instanceof TextOutputCallback) {
				// display the message according to the specified type
				TextOutputCallback toc = (TextOutputCallback)callbacks[i];
				switch (toc.getMessageType()) {
				case TextOutputCallback.INFORMATION:
					System.out.println(toc.getMessage());
					break;
				case TextOutputCallback.ERROR:
					System.err.println("ERROR: " + toc.getMessage());
					break;
				case TextOutputCallback.WARNING:
					System.err.println("WARNING: " + toc.getMessage());
					break;
				default:
					throw new java.io.IOException(
						"Unsupported message type: " + toc.getMessageType());
				}

			} else if (callbacks[i] instanceof NameCallback) {
				// Obtain username
				NameCallback nc = (NameCallback)callbacks[i];
				if (username.getUsername() != null 
						&& username.getUsername().length() != 0)
					nc.setName(username.getUsername());
				else {
					promptForInfo();
					nc.setName(username.getUsername());
				}
			} else if (callbacks[i] instanceof PasswordCallback) {
				// Obtain password
				PasswordCallback pc = (PasswordCallback)callbacks[i];
				if (username.getPassword() == null
						|| username.getPassword().length() == 0)
					promptForInfo();
				if (username.getPassword() != null) // still might be null
					pc.setPassword(username.getPassword().toCharArray());				
			} else {
				throw new UnsupportedCallbackException(
						callbacks[i],
						"Unrecognized Callback");
			}
		}
	}
	
	/**
	  * Has the user fill in the username field via a dialog.
	  */
	private void promptForInfo() throws java.io.IOException
	{
		okHit = false;
		try { /*
			Object[] components = {
				new JLabel("Username:"),
				new JTextField(10),
				new JLabel("Password:"),
				new JPasswordField(10),
				new JButton("Ok")
			};
			((JButton) components[4]).addActionListener(new ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent ae)
				{
					okHit = true;
					java.awt.Component c = (java.awt.Component) ae.getSource();
					while (!(c instanceof java.awt.Window))
						c = c.getParent();
					((java.awt.Window)c).dispose();
				}
			});
			javax.swing.JOptionPane.showOptionDialog(
					null,
					"Please enter your username and password.",
					"RBNB Login Dialog:",
					javax.swing.JOptionPane.OK_CANCEL_OPTION,
					javax.swing.JOptionPane.PLAIN_MESSAGE,
					null,
					components,
					null
			); */
			final JDialog dlg = new JDialog(
					JOptionPane.getFrameForComponent(null), // the default frame
					"RBNB Login:", 
					true  // modal
			);
			final Container cp = dlg.getContentPane();
			final GridBagConstraints gbc = new GridBagConstraints();
			
			JTextField id, pwd;
			
			cp.setLayout(new GridBagLayout());
			
			// Set common constraints:
			gbc.gridwidth=1;
			gbc.gridheight = 1;
			gbc.weightx=1.0;
			gbc.weighty=1.0;
			gbc.fill=gbc.NONE;
			gbc.insets.left = gbc.insets.top = 10;
			gbc.gridx=0;
			gbc.gridy=0;
			
			Utility.addComponent(cp, new JLabel("Username:"), gbc);
			gbc.insets.top = 5;
			Utility.addComponent(cp, new JLabel("Password:"), gbc);
			gbc.gridx = 1; gbc.gridy = 0; 
			gbc.insets.left = 5; gbc.insets.right = 10;
			gbc.insets.top = 10;
			Utility.addComponent(cp, id = new JTextField(10), gbc);
			gbc.insets.top = 5;
			Utility.addComponent(cp, pwd = new JPasswordField(10), gbc);
			gbc.gridx = 0; gbc.gridwidth = 2;
			JButton jb = (JButton) Utility.addComponent(
					cp, new JButton("Ok"), gbc);
			jb.addActionListener(new ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent ae)
				{
					okHit = true;
					dlg.dispose();
				}
			});
			dlg.getRootPane().setDefaultButton(jb);
			dlg.pack();
			try {
			// This was added in a fairly recent version of Java, so may throw:
				dlg.setLocationRelativeTo(null);
			} catch (Exception e) { } // just ignore

			dlg.setVisible(true);
			if (okHit) {
				username.setUsername(id.getText());
				username.setPassword(pwd.getText());
			} else throw new java.io.IOException(
					"User declined to provide security information.");
			
		} catch (Error e) {  // thrown if the classloader cannot load one of the
			//  swing components.
			throw new java.io.IOException(
					"Unable to produce username/password input dialog."
			);
		}
	}
	
	private final Username username;
	private boolean okHit;
} // end class InternalCallbackHandler
	
